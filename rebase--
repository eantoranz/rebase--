#!/bin/env python3

# Copyright 2025 Edmundo Carmona Antoranz
# Released under the terms of GPLv2.0

import argparse
import pygit2
import sys


def die_with_error(error: str) -> None:
    sys.stderr.write(f"{error}\n")
    sys.stderr.flush()
    sys.exit(1)


def get_commit(obj: pygit2.Object) -> pygit2.Commit:
    current_object = obj
    while True:
        if current_object is None:
            die_with_error(f"Could not get commit from {obj}")
        if isinstance(current_object, pygit2.Commit):
            return current_object
        if isinstance(current_object, pygit2.Tag):
            current_object = current_object.get_object()
        else:
            current_object = None  # force the error


class TreesIterator:

    def next_tree_item(self, tree_iterator):  # TODO what is the type of an interator?
        if tree_iterator is None:
            return None
        try:
            return tree_iterator.__next__()
        except StopIteration:
            return None

    def __init__(
        self,
        original_tree: pygit2.Tree,
        original_parent_trees: list[pygit2.Tree],
        rebased_parent_trees: list[pygit2.Tree],
    ):
        self.original_tree = original_tree
        self.original_parent_trees = original_parent_trees
        self.rebased_parent_trees = rebased_parent_trees

        self.original_tree_iterator = (
            original_tree.__iter__() if original_tree else None
        )
        self.original_parent_iterators = list(
            (parent.__iter__() if parent else None) for parent in original_parent_trees
        )
        self.rebased_parent_iterators = list(
            (parent.__iter__() if parent else None) for parent in rebased_parent_trees
        )

        self.original_tree_item = self.next_tree_item(self.original_tree_iterator)
        self.original_parent_tree_items = list(
            self.next_tree_item(parent_tree_iterator)
            for parent_tree_iterator in self.original_parent_iterators
        )
        self.rebased_parent_tree_items = list(
            self.next_tree_item(parent_tree_iterator)
            for parent_tree_iterator in self.rebased_parent_iterators
        )

    def _get_next_path(self) -> str | None:
        # Will return None if there are no more paths
        next_path = None
        items = list()
        if self.original_tree_item:
            items.append(self.original_tree_item)
        items.extend(item for item in self.original_parent_tree_items if item)
        items.extend(item for item in self.rebased_parent_tree_items if item)
        for item in items:
            if next_path is None:
                next_path = item.name
            else:
                if item.name < next_path:
                    next_path = item.name
        return next_path

    def _move_items_forward(self, path: str):
        if self.original_tree_item and self.original_tree_item.name == path:
            self.original_tree_item = self.next_tree_item(self.original_tree_iterator)
        for i in range(len(self.original_parent_tree_items)):
            item = self.original_parent_tree_items[i]
            if item and item.name == path:
                self.original_parent_tree_items[i] = self.next_tree_item(
                    self.original_parent_iterators[i]
                )
            item = self.rebased_parent_tree_items[i]
            if item and item.name == path:
                self.rebased_parent_tree_items[i] = self.next_tree_item(
                    self.rebased_parent_iterators[i]
                )

    def next_tree_items(
        self,
    ) -> (
        tuple[
            str,
            pygit2.Object | None,
            list[pygit2.Object | None],
            list[pygit2.Object | None],
        ]
        | None
    ):
        next_path = self._get_next_path()
        if next_path is None:
            # we are finished
            return None
        original_tree_item = (
            self.original_tree_item
            if self.original_tree_item and self.original_tree_item.name == next_path
            else None
        )
        original_parent_tree_items = list(
            (parent_item if parent_item and parent_item.name == next_path else None)
            for parent_item in self.original_parent_tree_items
        )
        rebased_parent_tree_items = list(
            (parent_item if parent_item and parent_item.name == next_path else None)
            for parent_item in self.rebased_parent_tree_items
        )

        # get next item for the trees that matched the path
        self._move_items_forward(next_path)
        return (
            next_path,
            original_tree_item,
            original_parent_tree_items,
            rebased_parent_tree_items,
        )


def get_filemode(item: pygit2.Object):
    if isinstance(item, pygit2.Blob):
        return pygit2.enums.FileMode.BLOB
    if isinstance(item, pygit2.Tree):
        return pygit2.enums.FileMode.TREE
    if isinstance(item, pygit2.Commit):
        return pygit2.enums.FileMode.COMMIT
    # TODO add the other types
    die_with_error(f"Unknown type for object {item}")


def merge_trees(
    repo: pygit2.Repository,
    commit_id: pygit2.Oid,
    commit_tree: pygit2.Tree,  # TODO not necessarily a root tree so maybe a better name would clear it up
    orig_parent_trees: list[pygit2.Tree],
    rebased_parent_trees: list[pygit2.Tree],
    verbose: bool,
    dirs: list[str] = [],
) -> tuple[bool, pygit2.Tree | str]:
    # if all the orig trees and the rebased trees are the same, we take commit_tree as is
    assert len(orig_parent_trees) == len(rebased_parent_trees)
    different_parents: set[tuple[pygit2.Object, pygit2.Object]] = (
        set()
    )  # tuple[0] = original, tuple[1] = rebased
    for orig_parent_tree, rebased_parent_tree in zip(
        orig_parent_trees, rebased_parent_trees
    ):
        if orig_parent_tree == rebased_parent_tree:
            # also works for None
            continue
        if (
            orig_parent_tree is None
            or rebased_parent_tree is None
            or orig_parent_tree.id != rebased_parent_tree.id
        ):
            different_parents.add((orig_parent_tree, rebased_parent_tree))
    if not different_parents:
        return True, commit_tree

    # if dealing with single-parent commits, there are a few other possibilities using the rebased parent tree
    if len(orig_parent_trees) == 1:
        orig_parent_tree = orig_parent_trees[0]
        rebased_parent_tree = rebased_parent_trees[0]
        if orig_parent_tree.id == commit_tree.id:
            return True, rebased_parent_tree
        if rebased_parent_tree.id == commit_tree.id:
            # delta original_parent_tree..commit_tree is already applied
            # in history of rebased_parent_tree. (TODO right??? please, verify this premise makes sense)
            return True, rebased_parent_tree

    # not everything in the trees match.... can we solve this puzzle?
    # We need to walk over the items in the trees, both sets of parents and commit_tree.
    # If we are lucky, we will be able to find correct resolutions for all the
    # separate items in the trees.
    trees_iterator = TreesIterator(commit_tree, orig_parent_trees, rebased_parent_trees)
    tree_builder = repo.TreeBuilder()
    while tree_items := trees_iterator.next_tree_items():
        path, commit_tree_item, original_parent_items, rebased_parent_items = tree_items
        different_parents = set()
        for original_parent_item, rebased_parent_item in zip(
            original_parent_items, rebased_parent_items
        ):
            if original_parent_item == rebased_parent_item:
                continue
            if (
                original_parent_item is None
                or rebased_parent_item is None
                or (original_parent_item.id != rebased_parent_item.id)
            ):
                different_parents.add((original_parent_item, rebased_parent_item))

        if not different_parents:
            if commit_tree_item:
                tree_builder.insert(
                    path, commit_tree_item.id, get_filemode(commit_tree_item)
                )
            continue

        # not everything matches
        if len(different_parents) == 1:
            different_parents = list(different_parents)
            # Is it still possible to use an early resolution?
            original_parent_item, rebased_parent_item = list(different_parents)[0]
            item_to_commit = None
            solved = False

            if commit_tree_item is None:
                # parents are different cause we would not be here otherwise
                if original_parent_item is None:
                    # we can use the rebased parent item
                    item_to_commit, solved = rebased_parent_item, True
                else:
                    # there was a deletion of the item
                    # we know that the rebased parent is not empty... can't solve it easily
                    pass
            else:
                # commit tree is set
                # we know that original/rebased parents are not the same
                if original_parent_item is None:
                    # rebased parent must set
                    if rebased_parent_item.id == commit_tree_item.id:
                        item_to_commit, solved = commit_tree_item, True
                    else:
                        # no easy resolution
                        pass
                else:
                    # original parent is set
                    if commit_tree_item.id == original_parent_item.id:
                        # we can use the rebased parent item
                        item_to_commit, solved = rebased_parent_item, True
                    else:
                        if rebased_parent_item is None:
                            # no easy fix
                            pass
                        else:
                            # rebased parent item is set
                            if rebased_parent_item.id == commit_tree_item.id:
                                # the change has already been applied on rebased_parent_item
                                item_to_commit, solved = rebased_parent_item, True
                            else:
                                # no easy fix
                                pass

            if solved:
                if item_to_commit is not None:
                    tree_builder.insert(
                        path, item_to_commit.id, get_filemode(item_to_commit)
                    )
                continue

        # if we are here, it's a hard one to tackle
        # we we are dealing with trees, we can recurse into them
        if (
            (commit_tree_item is None or isinstance(commit_tree_item, pygit2.Tree))
            and all(
                (parent is None or isinstance(parent, pygit2.Tree))
                for parent in original_parent_items
            )
            and all(
                (parent is None or isinstance(parent, pygit2.Tree))
                for parent in rebased_parent_items
            )
        ):
            # we can recurse into it
            dirs.append(path)
            recursive_result = merge_trees(
                repo,
                commit_id,
                commit_tree_item,
                original_parent_items,
                rebased_parent_items,
                verbose,
                dirs,
            )
            del dirs[-1]
            if recursive_result[0]:
                # we were able to solve it
                if recursive_result[1] is not None:
                    tree_builder.insert(
                        path, recursive_result[1].id, get_filemode(recursive_result[1])
                    )
                    continue
            else:
                return recursive_result  # no need to change it

        # if we are wondering around here, we need to go over the separate items in the trees
        full_path = ("/".join(dirs) + path) if dirs else path
        if verbose:
            print()
            sys.stderr.write(f"Failed to merge commit {commit_id}\n")
            sys.stderr.write(f"Current path: {full_path}\n")
            sys.stderr.write(
                f"original object: {commit_tree_item.id if commit_tree_item else '-'}\n"
            )
            sys.stderr.write(
                f"original parent objects: {list((parent.id if parent else "-") for parent in original_parent_items)}\n"
            )
            sys.stderr.write(
                f"rebased parent objects: {list((parent.id if parent else "-") for parent in rebased_parent_items)}"
            )
            sys.stderr.flush()
        return (
            False,
            f"We could not merge path {full_path}",
        )

    # Seems like we had no issues in the trees
    return True, repo.get(tree_builder.write())


def rebase(
    repo: pygit2.Repository,
    commit: pygit2.Commit,
    commits_map: dict[pygit2.Oid, pygit2.Commit],
    signature: pygit2.Signature,
    verbose: bool,
) -> pygit2.Commit | str:
    orig_parents = commit.parents
    orig_parent_trees = [parent.tree for parent in orig_parents]
    rebased_parents = [
        commits_map.get(orig_parent.id, orig_parent) for orig_parent in orig_parents
    ]
    rebased_parent_trees = [parent.tree for parent in rebased_parents]

    got_tree, result = merge_trees(
        repo,
        commit.id,
        commit.tree,
        orig_parent_trees,
        rebased_parent_trees,
        verbose=verbose,
    )
    if not got_tree:
        # could not generate a tree
        return result
    rebased_parent_ids = [parent.id for parent in rebased_parents]
    new_commit = repo.create_commit(
        None,
        commit.author,
        signature,
        commit.message,
        result.id,
        rebased_parent_ids,
    )

    return repo.get(new_commit)


parser = argparse.ArgumentParser(description="Simplified implementation of rebase")

parser.add_argument("upstream", type=str, help="What to use as the upstream.")
parser.add_argument(
    "source",
    nargs="?",
    default=None,
    type=str,
    help="What to rebase. Default: current branch",
)
parser.add_argument(
    "--onto",
    default=None,
    type=str,
    help="Rebase on top of this committish instead of upstream.",
)
parser.add_argument(
    "--verbose",
    action="store_true",
    default=False,
    help="Provide more information if it fails",
)

args = parser.parse_args()

repo = pygit2.Repository(".")
signature = pygit2.Signature(
    repo.config.__getitem__("user.name"),
    repo.config.__getitem__("user.email"),
)


try:
    upstream = get_commit(repo.revparse_single(args.upstream))
except Exception as e:
    die_with_error(f"Could not find upstream: {e}")

try:
    source = get_commit(repo.revparse_single(args.source if args.source else "HEAD"))
except Exception as e:
    die_with_error(f"Could not find source: {e}")

try:
    onto = get_commit(repo.revparse_single(args.onto) if args.onto else upstream)
except Exception as e:
    die_with_error(f"Could not find --onto: {e}")

merge_base_id = repo.merge_base(source.id, upstream.id)
if merge_base_id is None:
    die_with_error("No merge base between the upstream and the source")

rebase_walker = repo.walk(source.id)
rebase_walker.hide(merge_base_id)

commits_to_rebase = list(commit for commit in rebase_walker)
commits_to_rebase.reverse()

# mappings between original commits and their resulting equivalents
commits_map = {merge_base_id: onto}
counter = 0
commits_count = len(commits_to_rebase)
for commit in commits_to_rebase:
    counter += 1
    sys.stdout.write(f"\rRebasing {counter}/{commits_count}")
    result = rebase(repo, commit, commits_map, signature, args.verbose)
    if isinstance(result, str):
        print()
        die_with_error(f"Could not rebase commit {commit.id}: {result}")
    commits_map[commit.id] = result
print()
print(f"Resulting commit: {commits_map[source.id].id}")
